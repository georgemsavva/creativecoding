[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This is my blog for creative coding."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Posts",
    "section": "",
    "text": "art\n\n\nR\n\n\n\n\n\n\n\n\n\n\n\nNov 27, 2022\n\n\nGeorge\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nart\n\n\nR\n\n\n\n\n\n\n\n\n\n\n\nJul 7, 2022\n\n\nGeorge\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nart\n\n\nR\n\n\n\n\n\n\n\n\n\n\n\nMay 2, 2022\n\n\nGeorge\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nMay 2, 2022\n\n\nGeorge\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/flowfields/index.html",
    "href": "posts/flowfields/index.html",
    "title": "Flow fields",
    "section": "",
    "text": "Flow fields, or vector fields, are used a lot in generative art. Here I document an approach to using flow fields for art in R, leading to this image:\nI didn’t use field flows for ages as I wasn’t sure how I could add anything to what is already done, but lately I had a couple of ideas that seem innovative, or at least produce outputs that don’t look like anything else I’ve seen, so I think its worth documenting.\nSo I’ll demonstrate an approach creating flow fields using R, and then illustrate how they are used in my latest project."
  },
  {
    "objectID": "posts/flowfields/index.html#visualising-a-vector-field",
    "href": "posts/flowfields/index.html#visualising-a-vector-field",
    "title": "Flow fields",
    "section": "Visualising a vector field",
    "text": "Visualising a vector field\nAs with the mystery curves I use complex numbers, because this leads to some interesting maths in the 2D plane, and R makes working with complex numbers very natural.\nIn this first simple example I create a matrix of starting positions, \\(z\\), make a vector field \\(v\\) by rotating \\(z\\) position by just over 90 degrees to make a flow spiralling inward.\nDirection is measured by the argument of a complex number, and I want to keep the velocity of my flow constant, so I standardise \\(v\\) by diving by \\(\\left|v\\right|\\).\nFinally I increment the position using \\(z_{\\text{new}}=z+0.1\\times v\\) and draw arrows to the new points.\n\nset.seed(2911)\nlibrary(data.table)\n\nN=20\ndat <- expand.grid(x=seq(-1,1,l=20), y=seq(-1,1,l=20))\nsetDT(dat)\n\ndat[ , z := x+1i*y ]  # represent positions as complex numbers\ndat[ , v := z*exp(1i*3*pi/5) ] # create vector field by rotating z by 3pi/5.\ndat[ , v := v/Mod(v) ]\n\ndat[ , znew := z + .1*v  ]\n\nplot(dat$z, pch=19)\narrows(Re(dat$z), Im(dat$z), Re(dat$znew), Im(dat$znew), length=0.05)"
  },
  {
    "objectID": "posts/flowfields/index.html#adding-streamlines",
    "href": "posts/flowfields/index.html#adding-streamlines",
    "title": "Flow fields",
    "section": "Adding streamlines",
    "text": "Adding streamlines\nStreamlines (following individual trajectories) are created by iterating the flow function. I’ll create a matrix called pos to store all the points along the streamlines for plotting. (In R maticies can be complex, each element is a complex number so keeps the \\(x\\) and \\(y\\) positions.)\n\n# N streamlines and m iterations\nN=20\nm=100\n\n# each row is a streamline\npos=matrix(nrow=N, ncol=m)\n\n# make random starting positions\nstartz = runif(N,-1,1) + 1i*runif(N,-1,1) \n\n# put these starting positions into the first column of pos.\npos[,1] <- startz\n\n# now create the subsequent columns by iterating the equations above.\nfor(i in 2:m){\n  v <- pos[,i-1]*exp(1i*3*pi/5)\n  pos[,i] <- pos[,i-1] + .02 * v/Mod(v)\n}\n\nNow we can add the streamlines to the previous plot:\n\nplot(dat$z, pch=19,col=\"grey\")\narrows(Re(dat$z), Im(dat$z), Re(dat$znew), Im(dat$znew), length=0.05,col=\"grey\")\n\n#apply the `lines` function over the rows of pos to add the streams\napply(pos, 1, lines)\n\n\n\n\nNULL"
  },
  {
    "objectID": "posts/flowfields/index.html#rational-functions",
    "href": "posts/flowfields/index.html#rational-functions",
    "title": "Flow fields",
    "section": "Rational functions",
    "text": "Rational functions\nThe functions I’m going to use for my vector fields are rational functions, defined by the ratios of two polynomials. So our flow has modulus 1 and argument equal to the argument of:\nThat is, \\[f(z)=\\frac{\\prod_{i=1}^{n}(z-a_i)}{\\prod_{j=1}^{m}(z-b_j)}\\]\nI’ll illustrate this with a simple polynomial first, turning my last chunk into a function to plot a vector flow based on a function FUN, then passing it a simple polynomial:\n\n# takes a function and draws the vector field. \nplotFlow <- function(FUN,col=\"black\") {\n\n  dat <- expand.grid(x=seq(-1,1,l=20), y=seq(-1,1,l=20))\n  setDT(dat)\n  \n  dat[ , z := x+1i*y ]  # represent position as a complex number\n  dat[ , v := FUN(z) ]  # create vector field\n  dat[ , v := v/Mod(v) ]\n  dat[ , znew := z + .1*v  ]\n  plot(dat$z, pch=19,col=col)\n  arrows(Re(dat$z), Im(dat$z), Re(dat$znew), Im(dat$znew), length=0.05,col=col)\n}\n\nplotFlow( \\(z) (z-.5)*(z+.5)*z )\n\n\n\n\nNow we can just call this plotting function with whatever flow function we like. For example, lets plot the vectors associated with\n\\[f(z)=\\frac{z(z-0.5)(z+0.5)}{(z-0.5i+0.5)(z+0.5i-0.5)(z+0.1-0.1i)}\\]\n\nplotFlow( \\(z) (z-.5)*(z+.5)*z / ((z-0.5i+0.5)* (z+0.5i-0.5)*(z+.1-.1i)) )\n\n\n\n\nNULL\n\n\nAdding streamlines as previously:\n\nflowFunction = \\(z) (z-.5)*(z+.5)*z / ((z-0.5i+0.5)* (z+0.5i-0.5)*(z+.1-.1i))\n\n# N streamlines and m iterations\n\nmakeStreams <- function(startpos,m=200,FUN,d=0.02){\n  pos=matrix(nrow=N, ncol=m)\n  startz = runif(N,-1,1) + 1i*runif(N,-1,1)\n  pos[,1] <- startz\n  for(i in 2:m){\n    v <- FUN(pos[,i-1])\n    pos[,i] <- pos[,i-1] + d * v/Mod(v)\n  }\n  pos\n}\n\nN=100\nstartZ <- runif(N, -1,1) + 1i*runif(N, -1,1)\n\npos <- makeStreams(startZ, FUN = flowFunction)\n\nplotFlow(flowFunction, col=\"grey\")\napply(pos, 1, lines)\n\n\n\n\nNULL\n\n\nSo we have a system for making field flow images. We define a function for our vector field, then pick starting points and iterate to create the subsequent paths.\nThe artistic elements now all come from how we choose the function and start positions, and how we draw the paths we create.\nIf we massively increase the number of paths but reduce the number of iterations:\n\nN=1000\nstartZ <- runif(N, -1,1) + 1i*runif(N,-1,1)\npos <- makeStreams(startZ,FUN=flowFunction,d=0.01)\nplot(NA, xlim=c(-1,1), ylim=c(-1,1))\napply(pos, 1, lines)\n\n\n\n\nNULL\n\n\nThis is a bit dense. If we just draw points instead of lines we can control the density a bit more, and we can use the scattermore library to speed up the plotting enormously:\n\nlibrary(scattermore)\n\nWarning: package 'scattermore' was built under R version 4.1.3\n\npos <- cbind(Re(as.vector(pos)), Im(as.vector(pos)))\nscattermoreplot(pos,size=c(800,600), xlim=c(-1,1), ylim=c(-1,1))\n\n\n\n\nBefore we go any further, lets have a look at the implications of choosing specific roots for the polynomials in our rational function. The numerator here has roots at \\(0.5\\), \\(-0.5\\) and \\(0\\). The denominator’s root are at \\(-0.5+0.5i\\), \\(0.5-0.5i\\), and \\(-0.1+0.1i\\). Lets add these points onto the graph to see how they interact with the flow:\n\nscattermoreplot(pos,size=c(800,600), xlim=c(-1,1), ylim=c(-1,1))\npoints(c(-0.5+0.5i, 0.5-0.5i,-0.1+0.1i), col=\"blue\", cex=2,pch=4, lwd=4)\npoints(c(-0.5+0i, 0.5,0), col=\"red\", cex=2,pch=1, lwd=4)\n\n\n\n\nIt seems at least in this case that the roots of the numerator (red dots) represent sinks or sources for the flow, that is points where flows are either attracted to or repelled from. The roots of the denominator (the poles of the rational function; blue crosses) are saddle points, flows are attracted to them on one axis but repelled in others, hence flows appear to ‘miss’ them altogether.\nIn fact, this property generally holds, the zeros of our rational function will be sinks or sources, whereas the poles will be saddle points. We can prove this by noting that the argument of our rational function will be the sum of the arguments of the respective terms, and by thinking about how this sum changes as we move around a small area close to one of the poles or zeros.\nIn our image so far paths are starting from their randomly generated positions, and then flowing toward a sink or off the page. I think this looks messy, I would rather include the entire flow lines, and so I will add the flows both forwards and backwards from each start point. This way I generate the entire flow passing through each point, rather than just a random portion of it.\nI’m also changing the makeStreams function to return two column matrix of x and y positions in the form that scattermoreplot expects.\n\nmakeStreams <- function(startpos,m=100,FUN,d=0.1){\n  pos=matrix(nrow=length(startpos), ncol=m)\n  pos2=matrix(nrow=length(startpos), ncol=m)\n  pos[,1] <- startpos\n  pos2[,m] <- startpos\n  for(i in 2:m){\n    v <- FUN(pos[,i-1])\n    pos[,i] <- pos[,i-1] + d * v/Mod(v)\n  }\n  for(i in (m-1):1){\n    v <- FUN(pos2[,i+1])\n    pos2[,i] <- pos2[,i+1] - d * v/Mod(v)\n  }\n  pos <-cbind(pos,pos2) |> as.vector()\n  cbind(Re(pos),Im(pos))\n}\n\npos <- makeStreams(startZ, FUN=flowFunction,d=0.01)\n\nscattermoreplot(pos,size=c(1000,1000), xlim=c(-1,1), ylim=c(-1,1))\n\n\n\n\nWe can make a couple of easy improvements. First by squaring the aspect ratio of the plot, second by altering the spacing between the points. At the moment it is fixed, leading to some unintended patterns in the plot points, but we can easily set it to be random:\n\nmakeStreams <- function(startpos,m=100,FUN,d=0.1){\n  N=length(startpos)\n  pos=matrix(nrow=N, ncol=m)\n  pos2=matrix(nrow=N, ncol=m)\n  pos[,1] <- startpos\n  pos2[,m] <- startpos\n  for(i in 2:m){\n    v <- FUN(pos[,i-1])\n    pos[,i] <- pos[,i-1] + runif(N,0,2)*d * v/Mod(v)\n  }\n  for(i in (m-1):1){\n    v <- FUN(pos2[,i+1])\n    pos2[,i] <- pos2[,i+1] - runif(N,0,2)*d* v/Mod(v)\n  }\n  pos <-cbind(pos,pos2) |> as.vector()\n  cbind(Re(pos),Im(pos))\n}\n\npos <- makeStreams(startZ, FUN=flowFunction,d=0.01)\n\npar(mar=c(1,1,1,1))\nscattermoreplot(pos, size=c(1000,1000),xlim=c(-1,1), ylim=c(-1,1),asp=1,col=hsv(0,0,0,.5))"
  },
  {
    "objectID": "posts/flowfields/index.html#more-complex-flow-functions",
    "href": "posts/flowfields/index.html#more-complex-flow-functions",
    "title": "Flow fields",
    "section": "More complex flow functions",
    "text": "More complex flow functions\nThis image isn’t particularly appealing, but now that we have this system we can make a lot of beautiful images just choosing the locations of the poles and zeros of our flow function, the starting points of the flows and how they are rendered.\nFirst, lets add some more poles and zeros to our flow function. Our original function had three poles and three zeros. Here I’m going to add 20 poles and 20 zeros, choosing the location of each randomly within the canvas.\n\n# Choose the location of the poles and zeros\npoles <- runif(20,-1,1) + 1i*runif(20,-1,1)\nzeros <- runif(20,-1,1) + 1i*runif(20,-1,1)\n\n# Our flow function\nflowFunction <- function(z) {\n  fz = z-zeros[1]\n  for(i in zeros[-1]) fz = fz * (z-i)\n  for(i in poles) fz = fz / (z-i)\n  fz/Mod(fz)\n  }\n\n# Make the streams positions\npos <- makeStreams(startZ,m=500,FUN=flowFunction,d=0.002)\n\n# Plot\npar(mar=c(1,1,1,1))\nscattermoreplot(pos,size=c(1000,1000), xlim=c(-1,1), ylim=c(-1,1),asp=1,axes=F)\n\n\n\n\n\nChoosing which streamlines to plot by setting the starting points\nNext lets alter the starting positions of the flows. In the image above they are randomly selected throughout the canvas, but I could instead start them in a ring of radius 0.5 around the canvas centre. So here we’re seeing every streamline that passes through that ring.\nThe number of poles and zeros is also reduced.\n\nstartZ <- 0.6*exp(2i * pi * seq(0,1,l=300))\n\nset.seed(123)\npoles <- runif(5,-1,1) + 1i*runif(5,-1,1)\nzeros <- runif(10,-1,1) + 1i*runif(10,-1,1)\n\npos <- makeStreams(startZ,m=1000,FUN=flowFunction,d=0.002)\n\npar(mar=c(1,1,1,1))\nscattermoreplot(pos,size=c(1000,1000), xlim=c(-1,1), ylim=c(-1,1),asp=1,axes=F,col=hsv(0,0,0))\n\n\n\n\nNext exactly the same flow field but with many more streamlines (10000 vs 300) but each with fewer points included creates an effect that looks more like shading:\n\nstartZ <- 0.6*exp(2i * pi * seq(0,1,l=10000))\npos <- makeStreams(startZ,m=200,FUN=flowFunction,d=0.005)\npar(mar=c(1,1,1,1))\nscattermoreplot(pos,size=c(3000,3000), xlim=c(-1,1), ylim=c(-1,1),asp=1,axes=F,col=hsv(0,0,0))\n\n\n\n\nOr we could start them at random points along a line passing through the origin:\n\nN=5000\n\nstartZ <- runif(N,-1,1)*(1 + 1i*runif(1,-.5,.5))\n\npos <- makeStreams(startZ,m=200,FUN=flowFunction,d=0.01)\n\npar(mar=c(1,1,1,1))\nscattermoreplot(pos,size=c(2000,2000), xlim=c(-1,1), ylim=c(-1,1),asp=1,axes=F)\n\n\n\n\n\n\nChoosing locations for the poles and zeros\nHere I add 10 poles and 20 zeros arranges in a circle with radius 0.5.\n\npoles <- exp(2i*pi*runif(5))*0.3\nzeros <- exp(2i*pi*runif(10))*0.3\n\nstartZ = runif(10000, -1,1) + 1i*runif(10000,-1,1)\n\npos <- makeStreams(startZ,m=500,FUN=flowFunction,d=0.001)\n\npar(mar=c(1,1,1,1))\nscattermoreplot(pos,size=c(3000,3000),xlim=c(-1,1), ylim=c(-1,1),axes=F,\n                col=hsv(0,0,0,.5))"
  },
  {
    "objectID": "posts/flowfields/index.html#a-few-more-examples",
    "href": "posts/flowfields/index.html#a-few-more-examples",
    "title": "Flow fields",
    "section": "A few more examples",
    "text": "A few more examples\nFinally I’ll show a few more examples of different outputs from this system. Most have an element of randomness since the locations of the poles and zeros are selected randomly. Rerunning the code, or changing the seed where it is set, will lead to a different image.\nWhite on black works quite well.\n\npoles <- exp(2i*pi*runif(10))*0.4\nzeros <- exp(2i*pi*runif(20))*0.4\n\nstartZ <- 0.7*exp(2i * pi * seq(0,1,l=20000))\npos <- makeStreams(startZ,m=300,FUN=flowFunction,d=0.01)\n\n  par(mar=c(1,1,1,1), bg=\"#111111\")\n  scattermoreplot(pos, \n                size=c(1800,1800),\n                xlim=c(-1,1), \n                ylim=c(-1,1), \n                col=hsv(1,0,1,.1),\n                axes=F)\n\n\n\n\nI’ve left the ring of starting points visible on the image because I think it looks nice, but you could easily modify the makeStreams function to remove the starting points from the pos matrix.\nFor the next image, two concentric circles of starting points, one inside and one outside the ring of poles and zeros:\n\nset.seed(1214)\npolesandzeros <- .5*exp(2i*pi*seq(0,1,l=50)[-1])\npole = rbinom(20, 1,0.6)\npoles = polesandzeros[pole==1]\nzeros = polesandzeros[pole==0]\n\nN=20000\nstartZ <- c(\n  0.3*exp(2i * pi * seq(0,1,l=N/2)),\n  0.7*exp(2i * pi * seq(0,1,l=N/2))\n  )\n\npos <- makeStreams(startZ,m=300,FUN=flowFunction,d=0.01)\n\n  par(mar=0*c(1,1,1,1), bg=\"#111111\")\n  scattermoreplot(pos, \n                size=c(1800,1800),\n                xlim=c(-1,1), \n                ylim=c(-1,1), \n                col=hsv(1,0,1,.1),\n                axes=F)\n\n\n\n\nThe poles and zeros can be arranged along a polynomial, with four different circles providing starting positions for the flows.\nThe colour is fixed within each streamline but the saturation varies between them.\nFour circles provide starting points:\n\nset.seed(1214)\npolesandzeros <- .5*exp(2i*pi*seq(0,1,l=40)[-1])\npolesandzeros <- seq(-1,1,l=40)-0.5i*seq(-1,1,l=40) + .7i*seq(-1,1,l=40)^2 - .3i\npole = rbinom(39, 1,0.6)\npoles = polesandzeros[pole==1]\nzeros = polesandzeros[pole==0]\n\nstartZ <- c(\n  0.3*exp(2i * pi * seq(0,1,l=N/4))-0.3-0.3i,\n  0.2*exp(2i * pi * seq(0,1,l=N/4))+0.3-0.3i,\n  0.15*exp(2i * pi * seq(0,1,l=N/4))-0.6+0.6i,\n  0.5*exp(2i * pi * seq(0,1,l=N/4))+0.3+0.3i\n  )\n  \npos <- makeStreams(startZ,m=300,FUN=flowFunction,d=0.01)\n\npar(mar=0*c(1,1,1,1), bg=\"#111111\")\nscattermoreplot(pos,size=c(1800,1800),\n                xlim=c(-1,1), \n                ylim=c(-1,1), \n                col=hsv(0,rep(seq(0,1,l=N/4),4*600),1,0.1),\n                axes=F)\n\n\n\n\nNow here’s the code for the cover image for this post.\nThe poles and zeros are set along the same polynomial as in the previous example. The starting points are arranged in six concentric circles, and the streamlines from each have a different colour between red and blue.\n\nset.seed(1211)\n\npolesandzeros <- seq(-1,1,l=40)-0.5i*seq(-1,1,l=40) + .7i*seq(-1,1,l=40)^2 - .3i\n\npole = rbinom(39, 1,0.5)\npoles = polesandzeros[pole==1]\nzeros = polesandzeros[pole==0]\n\nN=60000\nstartZ <- c(\n  0.5*exp(2i * pi * seq(0,1,l=N/6)),\n  0.3*exp(2i * pi * seq(0,1,l=N/6)),\n  0.4*exp(2i * pi * seq(0,1,l=N/6)),\n  0.6*exp(2i * pi * seq(0,1,l=N/6)),\n  0.8*exp(2i * pi * seq(0,1,l=N/6)),\n  1.0*exp(2i * pi * seq(0,1,l=N/6))\n  )\n  \npos <- makeStreams(startZ,m=500,FUN=flowFunction,d=0.005)\n\ncol=rep(c(hsv(0,  1,0.5,0.4),\n          hsv(0.0,1,0.5,0.4),\n          hsv(0.1,1,0.5,0.4),\n          hsv(0.9,1,0.5,0.4),\n          hsv(0.8,1,0.5,0.4),\n          hsv(1,  1,0.5,0.1)\n          ), each=N/6)\ncol <- rep(col,1000)\n\npar(mar=0.1*c(1,1,1,1), bg=\"#dddddd\")\nscattermoreplot(pos,size=c(3000,3000),\n                xlim=c(-1,1), \n                ylim=c(-1,1), \n                col=col,\n                axes=F)"
  },
  {
    "objectID": "posts/flowfields/index.html#a-few-more-nice-outputs",
    "href": "posts/flowfields/index.html#a-few-more-nice-outputs",
    "title": "Flow fields",
    "section": "A few more nice outputs",
    "text": "A few more nice outputs\nThese are selected from randomly generated images based on the system described above, with various combinations of starting points and rational flow functions."
  },
  {
    "objectID": "posts/lissajous/index.html",
    "href": "posts/lissajous/index.html",
    "title": "Lissajous curves",
    "section": "",
    "text": "This post describes one of my favourite pieces of creative coding. The process followed here is more-or-less the process by which I came to the final image, although there was a a lot more trial and error the first time around! The work is based around Lissajous curves, which are widely used in mathematical art and take their name from Jules Lissajous who extensively explored them in the 19th century.\nAn image search for ‘Lissajous art’ or similar will show you a lot of ways people have used Lissajous curves, or more generally harmonographs, to make beautiful images.\nHere’s the final output we’re aiming for in this post:"
  },
  {
    "objectID": "posts/lissajous/index.html#lissajous-curves",
    "href": "posts/lissajous/index.html#lissajous-curves",
    "title": "Lissajous curves",
    "section": "Lissajous curves",
    "text": "Lissajous curves\nLissajous curves are the shapes traced out by sinusoidal motion in two dimensions. They are characterised by the equations:\n\\[\\begin{align*}\nx & = A\\times\\sin(f_x t - \\delta_x) \\\\\ny & = B\\times\\cos(f_y t - \\delta_y) \\\\\n\\end{align*}\\]\nWhere \\(A\\) and \\(B\\) are amplitudes, \\(f_x\\) and \\(f_y\\) are the frequencies of the motion and \\(\\delta_x\\) and \\(\\delta_y\\) the phase shift.\nIt is simple to draw a Lissajous curve in R using:\n\nt = seq(0,10,0.01)\n\nx = sin(2*pi*t)\ny = cos(3*pi*t)\n\nplot(x,y,type=\"l\",asp=1)\n\n\n\n\nBy visualising the motion in both dimensions it should be clear how the shapes arise:\n\nt = seq(0,2,0.01)\nx = sin(2*pi*t)\ny = cos(6*pi*t)\nlimits = c(-1,1)\n\nfor(i in seq(0,2,l=100)){\n  plot(x,y,type=\"l\",asp=1,xlim=1.2*limits,ylim=1.2*limits)\n  lines(x=c(sin(2*i*pi),sin(2*i*pi),-1.1),\n        y=c(-1.1,cos(6*pi*i),cos(6*pi*i)),pch=20,type=\"o\",lty=\"dashed\")\n  }\n\n\n\n\nBy changing the frequencies we can generate some familiar shapes:\n\nfor(i in 1:4) for(j in 2:5){\n  plot(x = sin(i*pi*t),\n       y=cos(j*pi*t),\n       type=\"l\",asp=1,xlim=limits,ylim=limits,\n       main=sprintf(\"i=%d; j=%d\",i,j))\n}\n\n\n\n\nThere are lots of interesting things to do with Lissajous curves. Eg we can overlay lots of curves with different frequencies.\n\nplot(NA, xlim=limits,ylim=limits,asp=1)\nfor(i in 1:4) for(j in 2:5){\n  points(x = sin(i*pi*t),y=cos(j*pi*t),type=\"l\")\n}\n\n\n\n\nNow lets add a few more curves, think about how the colour and intensity should depend on the frequency, remove the axes and annotation etc. This image isn’t great but you can start to see how you’d make something interesting..\n\npar(mar=c(1,1,1,1))\nplot(NA, xlim=limits,ylim=limits,asp=1,axes=F,ann=F)\nfor(i in 1:10) for(j in -10:10){\n  points(x = sin(i*pi*t),\n         y = cos(j*pi*t),type=\"l\",\n         lwd=5/(abs(i-j)+2),\n         col=hsv(h=.5+j/20,\n         s=1/(abs(i-j)+2),\n         v=1-1/(abs(i-j)+2),\n         alpha=1/(abs(i-j)+2)))\n}\n\n\n\n\nWe can make the frequencies increase as a geometric rather than an arithmetic sequence. Here the \\(x\\) frequency is fixed at 5 and the \\(y\\) frequency varies from \\(2\\times 2^{-4}\\) to \\(2\\times 2^4\\). Again this output isn’t especially pretty but its the set of curves we ultimately use for the final output.\n\nt = seq(0,10,0.001)\npar(mar=c(1,1,1,1))\nlimits=c(-1,1)\nplot(NA, xlim=limits,ylim=limits,asp=1,axes=F,ann=F)\nfor(i in 5) for(a in (-4:4)){\n  points(x = sin(i*pi*t),\n         y = cos(2*2^a*pi*t),type=\"l\",\n         lwd=2,\n         col=hsv(h=.6,\n                 s=.5,v=.5,\n                 alpha=1/(abs(a)+1)))\n}\n\n\n\n\nNow for the part where we diverge from classic Lissajous curve shape.\nThe next image is the same as the previous one, except that I have replaced \\(x\\) with \\(x^3\\) and \\(y\\) with \\(y^3\\). I also swapped the \\(x\\) and \\(y\\) axes because the image looked nicer that way around.\nRaising the \\(x\\) and \\(y\\) positions to the third power retains the range of the curve but bunches up the curves along the axes and makes the shapes more iteresting.\n\nt = seq(0,10,0.001)\npar(mar=c(1,1,1,1))\nlimits=c(-1,1)\nplot(NA, xlim=limits,ylim=limits,asp=1,axes=F,ann=F)\nfor(i in 5) for(a in (-4:4)){\n  points(y = sin(i*pi*t)^3,\n         x = cos(2*2^a*pi*t)^3,type=\"l\",\n         lwd=2,\n         col=hsv(h=.6,\n                 s=.5,v=.5,\n                 alpha=1/(abs(a)+1)))\n}\n\n\n\n\nThe other major innovation is to plot points of random sizes instead of lines, to create the textured effect in the final image.\nSomething else interesting happens when we switch to points instead of lines; since each path has the same number of points the shorter paths become denser so they are more prominent in the image:\n\nt = seq(0,50,l=1e4)\npar(mar=c(1,1,1,1))\nlimits=c(-1,1)\nplot(NA, xlim=limits,ylim=limits,asp=1,axes=F,ann=F)\nfor(i in 5) for(a in (-4:4)){\n  points(y = sin(i*pi*t)^3,\n         x = cos(2*2^a*pi*t)^3,type=\"p\",\n         cex=.5*runif(1000),\n         pch=20,\n         col=hsv(h=.6,\n                 s=runif(1000),v=runif(1000),\n                 alpha=runif(1000)/(abs(a)+1)))\n}\n\n\n\n\nThis is close to the final image! Tweaking some parameters can improve the balance between the curves, and lead us to something we are happy with.\nThe complete self-contained code for the final image is shown below.\nI have tweaked the point sizes a bit so they depend on which curve is being drawn, and used a normal distribution for the point sizes to get a longer tail of larger points.\nThe point hue is random, there is an off-white background and the number of points per curve is 30000. The frequency is always 5 in the \\(y\\) dimension, but varies from \\(2\\times 3^-4\\) to \\(2\\times 3^4\\) in the \\(x\\) dimension.\n\nset.seed(10072022)\nN=3e4\nt = seq(0,300,l=N)\npar(mar=2*c(1,1,1,1),bg=\"#fafafa\")\nlimits = c(-1,1)\n\nplot(NA, xlim=limits,ylim=limits,ax=F,an=F)\nfor(j in 2*3^(seq(-4,4,1))){\n  points(y = sin(5*pi*t)^3,\n         x = cos(j*pi*t)^3,\n         type=\"p\",\n         pch=20,\n         cex=rnorm(N)^1.0*.4*cos(t*pi/4+pi/3)+.05*(j==6)+.1*(j==2), # Random size\n         col=hsv(h=rnorm(N,.7,.1)%%1, # Random hue\n                 s=runif(N,0,1),      # Random saturation\n                 v=runif(N,0,1),      # Random value\n                 alpha=runif(N)))}    # Random alpha\n\n\n\n\nI am delighted with this image. The left and right panels make a lovely counterpoint to each other, as does the relationship between the two ‘major’ paths in each. The near-symmetry within each panel is an accident but I think it adds a lot to the final composition. ‘Cubing’ the Lissajous curves makes them familiar but not too familiar, in my opinion purely sinusoidal shapes can be a bit dull.\nThe intersections between paths are particularly pleasing, and the density and distribution of the points feels very organic. You could of course change the random number seed to get a different arrangement of sizes and colours.\nThe only thing I don’t like so much is the very high density of points in the dead centre of the image. I could try to artificially lighten this area but I don’t think that would help much. I also wonder if the overall colour and density is a little too uniform, but I can’t imagine how this could be improved."
  },
  {
    "objectID": "posts/mystery/index.html",
    "href": "posts/mystery/index.html",
    "title": "Mystery curves",
    "section": "",
    "text": "‘Mystery curves’ are described by Frank Farris in his book Creating Symmetry. They are a kind of circular harmonograph, each created by summing three circular components, and are the basis for a lot of my creative coding.\nFor example, these two pieces are both based on mystery curves:\nIn this post I’ll explain how mystery curves are put together, how I do this using R, and finish with the complete code of an animation."
  },
  {
    "objectID": "posts/mystery/index.html#artistic-augmentations",
    "href": "posts/mystery/index.html#artistic-augmentations",
    "title": "Mystery curves",
    "section": "Artistic augmentations",
    "text": "Artistic augmentations\nNow there’s a few things we would want to change about this plot. We don’t want the axes or the annotation, we would like it to be a connected as a line rather than a series of points, and we would like the aspect ratio to be 1. I also set and the linewidth lwd to be 2.\nSo we can amend our script as follows:\n\nt = seq(0, 4, l=1000)\nz = 1i^t\nplot(z, axes=FALSE, ann=FALSE, type=\"l\", lwd=2, asp=1)"
  },
  {
    "objectID": "posts/mystery/index.html#a-mystery-curve",
    "href": "posts/mystery/index.html#a-mystery-curve",
    "title": "Mystery curves",
    "section": "A mystery curve",
    "text": "A mystery curve\nNow to add the mystery elements. These are created by adding more circular motion with different amplitude, frequency and phase to our existing circle. For example, lets plot \\(z(t)=i^t + 0.5i^{5t+1}\\).\n\namp=0.5\nfreq=5\nphase=1\n\nz = 1i^t +                      # Our original circle\n  amp*(1i^(freq*t + phase))     # A new cirlce\n\nplot(z, axes=FALSE, ann=FALSE, type=\"l\", lwd=2, asp=1)\n\n\n\n\nThe animation below shows how this curve works. We are adding two circular motions together, the second rotating five times for every one rotation of the first, but with a smaller radius (0.5) and starting from a different angle. Notice how the second circle rotating five times for every one of the main circle leads to 4-fold rotational symmetry in the resulting shape:\n\namp=0.5\nfreq=5\nphase=1\nt = seq(0, 4, l=1000)\n\nfor(j in seq(1,1000,10)){\n\n      z = 1i^t +                        # Our original circle\n          amp*(1i^(freq*t + phase))     # A new cirlce\n      \n      plot(z, axes=FALSE, ann=FALSE, type=\"l\", lwd=2, asp=1)\n\n      lines(c(0,(1i^t)[j],z[j]),lwd=3,col=\"red\") # add lines\n      points(c(0,(1i^t)[j],z[j]),cex=2,pch=20)   # add points\n\n      }\n\n\n\n\nNow when we add another term we get a plot that looks even more interesting. Rather than defining \\(t\\) and typing out the formula for a circle each time, I will create a function to define a circle, then add three circles together as follows:\n\ncircle <- function(amp, freq, phase) amp*1i^(freq*seq(0,4,l=1000)+phase)\n\nz = circle(1,1,0) + circle(0.5,5,0) + circle(0.6,9,1)\n\nplot(z, axes=FALSE, ann=FALSE, type=\"l\", lwd=2, asp=1)\n\n\n\n\nWe can animate the motion similarly to the previous curve:\n\ncircle <- function(amp, freq, phase) amp*1i^(freq*seq(0,4,l=1000)+phase)\n\nfor(j in seq(1,1000,2)){\n\n      z = circle(1,1,0) + circle(0.5,5,0) + circle(0.6,9,1)\n      plot(z, axes=FALSE, ann=FALSE, type=\"l\", lwd=2, asp=1)\n      lps = cumsum(c(0,circle(1,1,0)[j],circle(0.5,5,0)[j],circle(0.6,9,1)[j]))\n      lines(lps,lwd=3,col=\"red\")\n      points(lps,cex=2,pch=20)\n      }\n\n\n\n\nNote that this plot, with three components having frequencies 1, 5 and 9 still has 4-fold rotational symmetry. As Farris explains, the image will have \\(N\\)-fold rotational symmetry if the frequency of each circle has the same remainder when divided by \\(N\\), that is, all frequencies equal mod \\(N\\). Here, 1, 5 and 9 are all 1 (mod 4) and so the image has 4-fold rotational symmetry.\nWe can include negative frequencies as well, so long as we remember this rule. Since \\(-7\\mod 4 =1\\) this will also have 4-fold rotational symmetry:\n\ncircle <- function(amp, freq, phase) amp*1i^(freq*seq(0,4,l=1000)+phase)\n\nfor(j in seq(1,1000,2)){\n      z = circle(1,1,0) + circle(0.5,5,0) + circle(0.6,-7,1)\n      plot(z, axes=FALSE, ann=FALSE, type=\"l\", lwd=2, asp=1)\n      \n      lps = cumsum(c(0,circle(1,1,0)[j],circle(0.5,5,0)[j],circle(0.6,-7,1)[j]))\n      lines(lps,lwd=3,col=\"red\")\n      points(lps,cex=2,pch=20)\n}\n\n\n\n\nWe can alter the shape of a curve over time by changing its parameters as we animate. In the code below, an animation is built with the parameter \\(j\\) which varies from 0 to 4 in 100 steps . The phase shift (starting angle) of the third component is set equal to \\(j\\).\nIn addition, the limits of the plot are now fixed at \\((-2,2)\\) in both dimensions.\n\ncircle <- function(amp, freq, phase) amp*1i^(freq*seq(0,4,l=1000)+phase)\nlimits=c(-1,1)*2\n\nfor( j in seq(0,4,l=100)[-1]){\n\n      z = circle(1,1,0) + circle(0.5,5,0) + circle(0.6,-7,j)\n      \n      plot(z, xlim=limits, ylim=limits,\n           axes=FALSE, ann=FALSE, type=\"l\", \n           lwd=2, asp=1, mar=c(0,0,0,0))\n      }"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "For the past few years I’ve been making pretty things with code.\nI’ve discovered a few tricks along the way, and the aim of this blog is to share these with the community.\nI have learnt a lot from others blog posts, and so with this site hope to give something back.\nMy main language for coding is R, although I hope that the posts will be useful for those using other languages."
  }
]